<!DOCTYPE html>
<html lang="en">
<!-- 
  path: src/presentation-custom/architecture.html
  description: Technical Documentation - System Design & Design Patterns v20.2.
  
  ABSTRACT:
  Detailed engineering overview of the Z-Realism ecosystem. 
  Covers the Hexagonal Architecture, SOLID implementation, 
  and Hardware Resource Management strategies.
  
  REFACTORING NOTE (v20.2):
  - Modularized navigation and footer via JS injection.
  - Retained Mermaid.js dependency for visual system modeling.
  - Documented Distributed Task Flow (Celery/Redis).

  author: Enrique González Gutiérrez <enrique.gonzalez.gutierrez@gmail.com>
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHITECTURE | Z-Realism Research Institute</title>

    <!-- FAVICON -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    
    <!-- Design System Linkage -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/info.css">
    
    <!-- Mermaid.js for architectural diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true, theme:'dark'});</script>
</head>
<body>
    <!-- Persistent Ambient Cyber-Grid -->
    <div class="grid-overlay"></div>

    <!-- 
      NAV INJECTION POINT: 
      The <nav> is automatically injected here by js/nav.js 
    -->

    <!-- Documentation Container -->
    <main class="info-container container">
        
        <a href="index.html" class="back-link">&larr; BACK TO GATEWAY</a>

        <header class="info-section">
            <span class="info-subtitle">SYSTEM DESIGN & DDD</span>
            <h1 class="info-title">The Engineering Blueprint</h1>
            <div class="info-content">
                <p>
                    Z-Realism v20.2 is built upon the <strong>Hexagonal Architecture</strong> (Ports & Adapters) pattern. 
                    This decoupling ensures that the core domain logic—the synthesis and evaluation of characters—remains 
                    independent of volatile technologies such as the specific Web Framework (FastAPI) or the 
                    Generative AI library (Diffusers).
                </p>
            </div>
        </header>

        <section class="info-section info-content">
            <h2>Hexagonal Implementation</h2>
            <p>
                By defining strict <strong>Ports</strong> (Interfaces) in our Domain layer, we can swap Infrastructure 
                Adapters without affecting the business logic. For instance, the system can switch between a 
                <code>StableDiffusionGenerator</code> and a <code>MockGenerator</code> (for non-GPU testing) 
                seamlessly, adhering to the <strong>Liskov Substitution Principle (SOLID)</strong>.
            </p>

            <!-- Mermaid Diagram: Hexagonal Structure -->
            <div class="info-card">
                <div class="mermaid">
                    graph LR
                    A[Presentation Layer] --> B[Application Layer]
                    B --> C[Domain Layer]
                    C --> D[Infrastructure Layer]
                    
                    subgraph Domain Boundary
                    C{Ports / Interfaces}
                    B(Use Cases / Orchestration)
                    end
                    
                    subgraph Adapters
                    D --> D1[SD1.5 / CUDA]
                    D --> D2[Celery / Redis]
                    D --> D3[OpenCV Analysis]
                    end
                </div>
            </div>

            <h2>Hardware Orchestration (VRAM Mutex)</h2>
            <p>
                To support high-resolution inference on consumer-grade laptops (GTX 1060 6GB), the architecture 
                implements a <strong>Hardware Tenancy Protocol</strong>. This is managed via a Redis-based Mutex 
                at the API Gateway.
            </p>

            <div class="info-card">
                <h4>Resource Management Logic:</h4>
                <ul class="info-list">
                    <li><strong>Single-Task Mutex:</strong> Prevents concurrent GPU requests that would trigger OOM crashes.</li>
                    <li><strong>Aggressive GC:</strong> The Worker explicitly purges VRAM and invokes Python Garbage Collection when switching between Static and Temporal models.</li>
                    <li><strong>Sequential Offloading:</strong> Model layers are streamed from System RAM (32GB) to VRAM (6GB) only during active computation.</li>
                </ul>
            </div>

            <h2>Distributed Task Flow</h2>
            <p>
                The lifecycle of a neural transformation is completely asynchronous. We utilize 
                <strong>Celery</strong> as the task orchestrator and <strong>Redis</strong> as the message broker. 
                This allows the API to remain responsive while the GPU performs heavy computational work.
            </p>

            <!-- Mermaid Diagram: Task Flow -->
            <div class="info-card">
                <div class="mermaid">
                    sequenceDiagram
                    participant UI as Client Lab
                    participant API as FastAPI Gateway
                    participant Q as Redis Queue
                    participant W as Inference Worker
                    
                    UI->>API: POST /transform
                    API->>API: Acquire VRAM Lock
                    API->>Q: Dispatch Task
                    Q->>W: Pull Task
                    loop Denoising Steps
                        W->>Q: Publish Telemetry
                        API-->>UI: Poll Progress
                    end
                    W->>Q: Success (Base64 + Metrics)
                    API->>UI: Return Final Manifold
                    API->>API: Release VRAM Lock
                </div>
            </div>
        </section>

    </main>

    <!-- 
      SHARED COMPONENTS 
    -->
    <script src="js/nav.js"></script>
    <script src="js/footer.js"></script>

</body>
</html>